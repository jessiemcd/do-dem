;ADD_PATH, '~/ssw/gen/idl/util/'
;ADD_PATH, '~/ssw/hinode/xrt/idl/util/'
;ADD_PATH, '~/ssw/sdo/aia/idl/response/'

;HISSW-STYLE IMPLEMENTATION OF XRT_DEM_ITERATIVE2 FOR MULTI-INSTRUMENT DEMS. DATA PREP 
;DONE IN PYTHON + LOADED BELOW. 

;Note that we will need to get our temperature response into a structure format similar to 
;the one generated by make_xrt_temp_resp
;required_tags(tresp, 'TYPE,NAME,TEMP,TEMP_UNITS,TEMP_RESP,TEMP_RESP_UNITS,LENGTH')

;INPUTS:
;---------

;OBS_INDEX: structure or string array (names of channels) (length: number of channels)

;OBS_VAL: This is the set of data values seen in the channels identified by OBS_INDEX, 
;respectively. Units = 'DN s^-1 pix^-1'.

;OBS_ERR: Input errors (on data values)

;TRMATRIX: temperature response matrix, which will be used to build TRESP ()"temp_resp" 
;structure array). Units: 'DN cm^5 s^-1 pix^-1'

;TEMPS: temperatures at which the response is given

;MC_ITER: # of iterations for MCMC (to get uncertainties in DEM solution)

;dT: temperature step (in logT) for output solutions. Note that poorly behaved solutions 
;sometimes result for small (<0.1) steps. 

;NAME: for naming things


OBS_INDEX = {{ obs_index }}
OBS_VAL = {{ obs_val | force_double_precision }}
OBS_ERR = {{ obs_err | force_double_precision }}
TRMATRIX = {{ trmatrix | force_double_precision }}
TEMPS = {{ temps | force_double_precision }}
mc_iter = {{ mc_iter }}
dT = {{ dT }}
Name = {{ Name }}
min_T = {{ min_T }}
max_T = {{ max_T }}

print, 'Using the following measurements:'
print, obs_index

tr_size = size(trmatrix)
;print, tr_size

trmatrix=transpose(trmatrix)
tr_size = size(trmatrix)
;print, tr_size

;Required tags as described in line ~1212 of xrt_dem_interative2.pro
tr_tagnames = ['type', 'temp', 'temp_units', 'temp_resp', 'temp_resp_units', 'length', 'name', 'confg']

;making a little structure to stand in for the {XRT_chn_config_ref} structure that
;xrt_dem_interative2.pro expects:
lilconfg = create_struct('name', obs_index)

tresp = create_struct(tr_tagnames, $
						'', 10^temps, '', 10^temps,'',0,'', lilconfg)
  ;; And initialize the tags.
;
tresp.type            = 'XRT_TEMP_RESP'
tresp.temp            = 10^temps
tresp.temp_units      = 'K'
tresp.temp_resp_units = 'DN cm^5 s^-1 pix^-1'
tresp.length          = tr_size[1]
tresp.name            = 'steve'


tresp = replicate(tresp, tr_size[2])

for i=0, tr_size[2]-1 do begin
	;;; Assign results into TR structure.
	tresp[i].temp_resp[0:tr_size[1]-1] = trmatrix[*,i]
endfor


xrt_dem_iterative2, obs_index, obs_val, tresp, logT_out, dem_out, obs_err=obs_err, $
					base_obs=base_obs, mod_obs=mod_obs, chisq=chisq, MC_ITER=mc_iter, $
					dT=dT, /quiet, min_T=min_T, max_T=max_T

;CONVERTING DEM_OUT INTO [CM^-5] RATHER THAN [CM^-5 K^-1] BY DIVIDING BY TEMPERATURE BIN WIDTH
;Note here using default value of dT in xrt_dem_iterative2 (0.1, logT space), change dT here if you specify 
;it to be different than the default. 

dlogTfac=10.0^logT_out*alog10(10.0^dT)
;print, size(dlogTfac)
;print, size(dem_out)
;print, 'From docs, CHISQ[i] = total (BASE_OBS[*,i]-MOD_OBS[*,i]/OBS_ERR[*])^2'
;print, 'Where obs_err is input uncertainty, base_obs is input observations, mod_obs is predicted observations based on DEM result'
;print, 'Index zero is the soultions w/ base_obs=obs_val, all others are from base_obs=obs_val+noise (random obs_err noise)'
print, 'CHISQ (0): ', chisq[0]

;print, size(dem_out[0,*])

;
;plot, logT_out, dem_out[*,0]*dlogTfac, /ylog, yrange=[1e10,1e32]
;loadct, 13
;
;colorr=0
;for i=0, n_elements(obs_val)-1 do begin
;	colorr+=40
;	res=(obs_val[i]/trmatrix[*,i])
;	oplot, temps, res, color=colorr
;endfor
;loadct, 0	


;WRITE_PNG, 'idl_plot_output_MC'+strtrim(mc_iter, 2)+'_'+name+'.png', TVRD(/TRUE)	








;iterative_wrapper_hissw, obs_val=obs_val, obs_err=obs_err, temps=temps, $
;							obs_index=obs_index, trmatrix=trmatrix, mc_iter=mc_iter, dT=dT

